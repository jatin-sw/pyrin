# -*- coding: utf-8 -*-
"""
token handlers base module.
"""

import time

from jwt import decode, encode

import pyrin.configuration.services as config_services

from pyrin.core.context import CoreObject, DTO
from pyrin.core.exceptions import CoreNotImplementedError
from pyrin.settings.static import APPLICATION_ENCODING
from pyrin.utils import unique_id


class TokenBase(CoreObject):
    """
    token base class.
    """

    def __init__(self, name, **options):
        """
        initializes an instance of TokenBase.

        :param str name: name of the token handler.
        """

        CoreObject.__init__(self)

        self._set_name(name)

    def generate_access_token(self, payload, **options):
        """
        generates an access token from the given inputs and returns it.
        the generated token is in the form of `header_hash.payload_hash.signature_hash`
        and each part is encoded using a signing key.

        :param dict payload: a dictionary containing key/values as payload.
                             note that for better performance, keep payload
                             as small as possible.

        :keyword dict custom_headers: a dictionary containing custom headers.

        :keyword bool is_fresh: indicates that this token is fresh.
                                being fresh means that token is generated by
                                providing user credentials to server.
                                if not provided, defaults to False.

        :returns: token.

        :rtype: bytes
        """

        updated_payload = payload or {}
        updated_payload.update(**self._get_access_token_required_claims())

        return self._generate_token(updated_payload, **options)

    def generate_refresh_token(self, payload, **options):
        """
        generates a refresh token from the given inputs and returns it.
        the generated token is in the form of `header_hash.payload_hash.signature_hash`
        and each part is encoded using a signing key.

        :param dict payload: a dictionary containing key/values as payload.
                             note that for better performance, keep payload
                             as small as possible.

        :keyword dict custom_headers: a dictionary containing custom headers.

        :keyword bool is_fresh: indicates that this token is fresh.
                                being fresh means that token is generated by
                                providing user credentials to server.
                                if not provided, defaults to False.

        :returns: token.

        :rtype: bytes
        """

        updated_payload = payload or {}
        updated_payload.update(**self._get_refresh_token_required_claims())

        return self._generate_token(updated_payload, **options)

    def _generate_token(self, payload, **options):
        """
        generates a token from the given inputs and returns it.

        :param dict payload: a dictionary containing key/values as payload.
                             note that for better performance, keep payload
                             as small as possible.

        :keyword dict custom_headers: a dictionary containing custom headers.

        :keyword bool is_fresh: indicates that this token is fresh.
                                being fresh means that token is generated by
                                providing user credentials to server.
                                if not provided, defaults to False.

        :returns: token.

        :rtype: bytes
        """

        is_fresh = options.get('is_fresh', False)
        updated_payload = payload or {}
        updated_payload.update(is_fresh=is_fresh)

        return encode(updated_payload,
                      self._get_encoding_key(),
                      self._get_algorithm(),
                      options.get('custom_headers', None))

    def get_payload(self, token, **options):
        """
        decodes token and gets the payload data.

        :param bytes token: token to get it's payload.

        :rtype: dict
        """

        return decode(token.decode(APPLICATION_ENCODING),
                      self._get_decoding_key(),
                      True,
                      self._get_algorithm(),
                      self._get_default_options())

    def _get_common_required_claims(self):
        """
        gets a dictionary containing common required claims
        for access and refresh tokens.

        :returns: dict(str jti: jwt id,
                       int iat: issued time)

        :rtype: dict
        """

        now = time.time()

        return DTO(jti=str(unique_id.generate_uuid4()),
                   iat=now)

    def _get_access_token_required_claims(self):
        """
        gets a dictionary containing required claims for access token.

        :returns: dict(str jti: jwt id,
                       int iat: issued time,
                       int exp: expire time)

        :rtype: dict
        """

        common_required = self._get_common_required_claims()
        expire_duration = self._get_access_token_lifetime()
        expiration = common_required['iat'] + expire_duration
        common_required.update(exp=expiration)

        return common_required

    def _get_refresh_token_required_claims(self):
        """
        gets a dictionary containing required claims for refresh token.

        :returns: dict(str jti: jwt id,
                       int iat: issued time,
                       int exp: expire time)

        :rtype: dict
        """

        common_required = self._get_common_required_claims()
        expire_duration = self._get_refresh_token_lifetime()
        expiration = common_required['iat'] + expire_duration
        common_required.update(exp=expiration)

        return common_required

    def _get_default_options(self):
        """
        gets a dictionary containing default options.

        :returns: dict(bool verify_signature: verify signature,
                       bool verify_exp: verify expire time,
                       bool verify_nbf: verify not before,
                       bool verify_iat: verify issued at,
                       bool verify_aud: verify audience,
                       bool verify_iss: verify issuer,
                       bool require_exp: requires expire time,
                       bool require_iat: requires issued time,
                       bool require_nbf: requires not before time)

        :rtype: dict
        """

        return DTO(verify_signature=True,
                   verify_exp=True,
                   verify_nbf=True,
                   verify_iat=True,
                   verify_aud=True,
                   verify_iss=True,
                   require_exp=True,
                   require_iat=True,
                   require_nbf=False)

    def _get_encoding_key(self, **options):
        """
        gets the signing key for encoding.

        :raises CoreNotImplementedError: core not implemented error.

        :rtype: str
        """

        raise CoreNotImplementedError()

    def _get_decoding_key(self, **options):
        """
        gets the signing key for decoding.

        :raises CoreNotImplementedError: core not implemented error.

        :rtype: str
        """

        raise CoreNotImplementedError()

    def _get_access_token_lifetime(self, **options):
        """
        gets access token lifetime.

        :rtype: int
        """

        return config_services.get('security', 'token', 'access_token_lifetime', **options)

    def _get_refresh_token_lifetime(self, **options):
        """
        gets refresh token lifetime.

        :rtype: int
        """

        return config_services.get('security', 'token', 'refresh_token_lifetime', **options)

    def _get_algorithm(self):
        """
        gets the algorithm for signing the token.

        :raises CoreNotImplementedError: core not implemented error.

        :rtype: str
        """

        raise CoreNotImplementedError()

    def generate_key(self, **options):
        """
        generates a valid key for this handler and returns it.

        :keyword int length: the length of generated key in bytes.
                             note that some token handlers may not accept custom
                             key length so this value would be ignored on those handlers.

        :raises CoreNotImplementedError: core not implemented error.

        :rtype: Union[str, tuple(str, str)]
        """

        raise CoreNotImplementedError()


class SymmetricTokenBase(TokenBase):
    """
    symmetric token base class.
    this token type uses a single symmetric key for decoding and encoding.
    """

    def __init__(self, name, **options):
        """
        initializes an instance of SymmetricTokenBase.

        :param str name: name of the token handler.
        """

        TokenBase.__init__(self, name, **options)

    def _get_decoding_key(self):
        """
        gets the signing key for decoding.

        :rtype: str
        """

        return self._get_encoding_key()

    def generate_key(self, **options):
        """
        generates a valid key for this handler and returns it.

        :keyword int length: the length of generated key in bytes.
                             note that some token handlers may not accept custom
                             key length so this value would be ignored on those handlers.

        :raises CoreNotImplementedError: core not implemented error.

        :rtype: str
        """

        raise CoreNotImplementedError()


class AsymmetricTokenBase(TokenBase):
    """
    asymmetric token base class.
    this token type uses a pair of public/private asymmetric keys for decoding and encoding.
    """

    def __init__(self, name, **options):
        """
        initializes an instance of AsymmetricTokenBase.

        :param str name: name of the token handler.
        """

        TokenBase.__init__(self, name, **options)

    def generate_key(self, **options):
        """
        generates a valid public/private key for this handler and returns it.

        :keyword int length: the length of generated key in bytes.
                             note that some token handlers may not accept custom
                             key length so this value would be ignored on those handlers.

        :raises CoreNotImplementedError: core not implemented error.

        :returns tuple(str public_key, str private_key)

        :rtype: tuple(str, str)
        """

        raise CoreNotImplementedError()
